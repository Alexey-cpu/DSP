//-----------------------------------------------------------------------------------------------------------------------------------
// A.M. Tykvinsky, 30.09.2020
//-----------------------------------------------------------------------------------------------------------------------------------
// COMPLEX NUMBERS OPERATIONS CLASS:
//-----------------------------------------------------------------------------------------------------------------------------------

#ifndef _CPLX_OPERATIONS_HPP
#define _CPLX_OPERATIONS_HPP

#include <math.h>

class cplx_operations
{

public:

	// выходные переменные блока:
	double m_Re;
	double m_Im;
	double m_ARG;
	double m_ABS;
	double m_Re_I1;
	double m_Im_I1;
	double m_Re_I2;
	double m_Im_I2;
	double m_Re_I0;
	double m_Im_I0;

	// конструктор по умолчанию:
	cplx_operations();

	// деструктор:
	~cplx_operations();
	
	// встроенные функции:
	//-----------------------------------------------------------------------------------------------------------------------------------
	// функциЯ умножениЯ двух комплексных чисел
	inline int mul(double Re1, double Im1, double Re2, double Im2 )
	{
		// Re1 - действительнаЯ часть первого комплексного числа
		// Im1 - мнимаЯ часть первого комплексного числа
		// Re2 - действительнаЯ часть второго комплексного числа
		// Im2 - мнимаЯ часть второго комплексного числа

		// умножение двух комплексных чисел:
		m_Re  = Re1 * Re2 - Im1 * Im2;
		m_Im  = Re1 * Im2 + Re2 * Im1;
		
		return 0;
	}
	//-----------------------------------------------------------------------------------------------------------------------------------
	// функциЯ делениЯ двух комплексных чисел:
	inline int div(double Re1, double Im1, double Re2, double Im2 )
	{
		// Re1 - действительнаЯ часть первого комплексного числа
		// Im1 - мнимаЯ часть первого комплексного числа
		// Re2 - действительнаЯ часть второго комплексного числа
		// Im2 - мнимаЯ часть второго комплексного числа

		// деление двух комплексных чисел:
		m_Re = (Re1 * Re2 + Im1 * Im2) / (Re2 * Re2 + Im2 * Im2);
		m_Im = (Re2 * Im1 - Re1 * Im2) / (Re2 * Re2 + Im2 * Im2);

		return 0;
	}
	//-----------------------------------------------------------------------------------------------------------------------------------
	// функциЯ сложениЯ двух комплексных чисел:
	inline int add(double Re1, double Im1, double Re2, double Im2 )
	{
		// сложение двух комплексных чисел:
		m_Re = Re1 + Re2;
		m_Im = Im1 + Im2;

		return 0;
	}
	//-----------------------------------------------------------------------------------------------------------------------------------
	// функциЯ вычитаниЯ двух комплексных чисел:
	inline int sub(double Re1, double Im1, double Re2, double Im2 )
	{
		// Re1 - действительнаЯ часть первого комплексного числа
		// Im1 - мнимаЯ часть первого комплексного числа
		// Re2 - действительнаЯ часть второго комплексного числа
		// Im2 - мнимаЯ часть второго комплексного числа

		// вычитание двух комплексных чисел:
		m_Re = Re1 - Re2;
		m_Im = Im1 - Im2;

		return 0;
	}
	//-----------------------------------------------------------------------------------------------------------------------------------
	// функциЯ извлечениЯ квадратного корнЯ из комплексного числа:
	inline int sqr(double Re, double Im)
	{
		// Re - действительнаЯ часть комплексного числа
		// Im - мнимаЯ часть комплексного числа

		// извлечение квадратного корнЯ из комплексного числа:
		m_ABS = sqrt(Re*Re + Im * Im);
		m_ARG = atan2(Im , Re);

		m_Re = sqrt(m_ABS) * cos(m_ARG / 2);
		m_Im = sqrt(m_ABS) * sin(m_ARG / 2);

		return 0;
	}
	//-----------------------------------------------------------------------------------------------------------------------------------
	// функция расчета модуля комплексного числа:
	inline int abs(double Re, double Im)
	{
		// Re - действительнаЯ часть комплексного числа
		// Im - мнимаЯ часть комплексного числа

		// расчет модуля комплексного числа:
		m_ABS = sqrt(Re*Re + Im * Im);

		return 0;
	}
	//-----------------------------------------------------------------------------------------------------------------------------------
	// функция расчета аргумента комплексного числа:
	inline int arg(double Re, double Im)
	{
		// Re - действительнаЯ часть комплексного числа
		// Im - мнимаЯ часть комплексного числа

		// расчет аргумента комплексного числа:
		m_ARG = atan2(Im, Re);

		return 0;
	}
	//-----------------------------------------------------------------------------------------------------------------------------------
	// функция расчета симметричных составляющих:
	inline int sim_comp(double Re_A, double Im_A , double Re_B, double Im_B , double Re_C, double Im_C)
	{
		// Re_A - проекция вектора фазы А на ось X
		// Im_A - проекция вектора фазы А на ось Y
		// Re_B - проекция вектора фазы B на ось X
		// Im_B - проекция вектора фазы B на ось Y
		// Re_C - проекция вектора фазы C на ось X
		// Im_C - проекция вектора фазы C на ось Y

		// прямая последовательность
		m_Re_I1 = (Re_A - (Re_B * 0.500 + Im_B * 0.866) - (Re_C * 0.500 - Im_C * 0.866)) * 0.33333333333333333333333333333;
		m_Im_I1 = (Im_A + (Re_B * 0.866 - Im_B * 0.500) - (Re_C * 0.866 + Im_C * 0.500)) * 0.33333333333333333333333333333;

		// обратная последовательность:
		m_Re_I2 = (Re_A - (Re_B * 0.500 - Im_B * 0.866) - (Re_C * 0.500 + Im_C * 0.866)) * 0.33333333333333333333333333333;
		m_Im_I2 = (Im_A - (Re_B * 0.866 + Im_B * 0.500) + (Re_C * 0.866 - Im_C * 0.500)) * 0.33333333333333333333333333333;

		// нулевая последовательность:
		m_Re_I0 = (Re_A + Re_B + Re_C) * 0.33333333333333333333333333333;
		m_Im_I0 = (Im_A + Im_B + Im_C) * 0.33333333333333333333333333333;

		return 0;
	}
	//-----------------------------------------------------------------------------------------------------------------------------------
	
};

#endif