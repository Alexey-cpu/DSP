// A.M. Tykvinsky , 29.09.2020

#include "wind_fcn.hpp"

// ОКОННЫЕ ФУНКЦИИ

// Примечания к реализации оконных функций:
// 1. Большинство оконных функций реализованы по формулам, описанным в документации к ПК Matlab;
// 2. Коэффициенты окна Дольфа - Чебышева во временной области считаются по принципу, описанному в
//    "practicalcryptography.com/miscellaneous/machine-learning/implementing-dolph-chebyshev-window/"
//    (реализация функции взята с указанного выше сайта и адаптированна под задачи, решаемые на ПО терминала МКПА-РЗ)
// 3. В некоторых оконных функциях значения коэффициентов могут отличаться от ПК MatLab в 3 - 4 ом знаке после запятой. 
//    Это обусловленно тем, что в ПК MatLab используется тип long double, а в задачах, решаемых на ПО терминала МКПА-РЗ - double 

// ОКОННАЯ ФУНКЦИЯ
//------------------------------------------------------------------------------
//Конструктор:
wind_fcn::wind_fcn() 
{
	m_wind_ready = false;
	m_BUFF_WIND  = NULL;
}
//------------------------------------------------------------------------------
//Деструктор:
wind_fcn::~wind_fcn() {};
//------------------------------------------------------------------------------
// функция инициализации окна:
int wind_fcn::windInit(int order)
{
	// инициализация буффера для хранения коэффициентов оконной функции:
	m_order = order;
	m_BUFF_WIND = NULL;
	return 0;
}
//------------------------------------------------------------------------------
// функция выделения памяти:
int wind_fcn::allocate() 
{
	// выделение памяти под буффер для хранения коэффициентов оконной функции:
	m_BUFF_WIND = new double [m_order];

	return 0;
}
//------------------------------------------------------------------------------
// функция освобождения памяти:
int wind_fcn::deallocate()
{
	// освобождение памяти от буффера для хранения коэффициентов оконной функции:

	if (m_BUFF_WIND != NULL) 
	{
		delete[] m_BUFF_WIND;
		m_BUFF_WIND = NULL;
	}

	return 0;
}
//------------------------------------------------------------------------------
//функция расчета АЧХ и ФЧХ оконной функции:
//(возможно будет реализована возможность компенсации АЧХ и ФЧХ оконной функции)
int wind_fcn::FreqCharacteristics()
{
	return 0;
};

//------------------------------------------------------------------------------
// Окно Барлета:
int wind_fcn::Bartlett()
{
	// выделяем память для хранения коэффициентов оконной функции:
	allocate();

	double Ns = (double)m_order;

	// расчет коэффициентов оконной функции:
	for (int n = 0; n < Ns ; n++)
	{
		if ( n <= (Ns-1)/2) 
		{
			m_BUFF_WIND[n] = 2*n / (Ns-1);
		}
		else 
		{
			m_BUFF_WIND[n] = 2 - 2 * n / (Ns-1);
		}
	}

	// выдача сигнала о готовности оконной функции:
	m_wind_ready = true;

	return 0;
}
//------------------------------------------------------------------------------
int wind_fcn::BartlettHanning()
{
	// выделяем память для хранения коэффициентов оконной функции:
	allocate();

	double Ns = (double)m_order;

	// расчет коэффициентов оконной функции:
	for (int n = 0; n < Ns ; n++)
	{
		m_BUFF_WIND[n] = 0.62 - 0.48 * fabs( n / (Ns-1)-0.5) + 0.38 * cos(PI2 * (n / (Ns - 1) - 0.5));
	}

	// выдача сигнала о готовности оконной функции:
	m_wind_ready = true;

	return 0;
}
//------------------------------------------------------------------------------
// Окно Блакмана:
int wind_fcn::Blackman()
{
	// выделяем память для хранения коэффициентов оконной функции:
	allocate();

	double Ns = (double)m_order;

	// расчет коэффициентов оконной функции:
	for (int n = 0; n < Ns ; n++)
	{
		m_BUFF_WIND[n] = 0.42 - 0.50 * cos(2 * PI0 * n / (Ns - 1) ) + 0.08 * cos(4 * PI0 * n / (Ns - 1));
	}

	// выдача сигнала о готовности оконной функции:
	m_wind_ready = true;

	return 0;
}
//------------------------------------------------------------------------------
// Окно Блакмана - Харриса:
int wind_fcn::BlackmanHarris()
{
	// выделяем память для хранения коэффициентов оконной функции:
	allocate();

	double Ns = (double)m_order;

	// расчет коэффициентов оконной функции:
	for (int n = 0; n < Ns; n++)
	{
		m_BUFF_WIND[n] = 0.35875 - 0.48829 * cos(2 * PI0 * n / (Ns - 1)) + 0.14128 * cos(4 * PI0 * n / (Ns - 1)) - 0.01168 * cos(6 * PI0 * n / (Ns - 1));
	}

	// выдача сигнала о готовности оконной функции:
	m_wind_ready = true;

	return 0;
}
//------------------------------------------------------------------------------
// Окно Бохмана:
int wind_fcn::Bohman()
{
	// выделяем память для хранения коэффициентов оконной функции:
	allocate();

	double Ns = ceil( (double)m_order / 2);
	double n  = 0;

	// расчет коэффициентов оконной функции:
	for (int k = 0; k < m_order; k++)
	{
		n = k - Ns;
		if (n >= 0)  n = k - Ns + 1;
		m_BUFF_WIND[k] = (1 - fabs(n / (Ns + 1))) * cos(PI0 * fabs(n / (Ns + 1))) + 1 / PI0 * sin(PI0 * fabs(n / (Ns + 1)));
	}

	// выдача сигнала о готовности оконной функции:
	m_wind_ready = true;

	return 0;
}

//------------------------------------------------------------------------------
// Окно Чебышева с функцией расчета коэффициентов полинома Чебышева первого рода:
int wind_fcn::Chebyshev(double atten)
{
	// выделяем память для хранения коэффициентов оконной функции:
	allocate();

	int    Ns = m_order;

	int    nn, kk;
	double M, n, sum = 0, max = 0;
	double tg = pow(10, atten / 20);
	double x0 = cosh((1.0 / (Ns - 1))*acosh(tg));
	M = (Ns - 1) / 2;

	if (Ns % 2 == 0) M = M + 0.5;

	for (nn = 0; nn < (Ns / 2 + 1); nn++) 
	{
		n = nn - M;

		sum = 0;

		for (kk = 1; kk <= M; kk++) 
		{
			sum += cheby_poly(Ns - 1, x0*cos(PI0*kk / Ns))*cos(2.0*n*PI0*kk / Ns);
		}

		m_BUFF_WIND[nn] = tg + 2 * sum;
		m_BUFF_WIND[(int)Ns - nn - 1] = m_BUFF_WIND[nn];

		if (m_BUFF_WIND[nn] > max)max = m_BUFF_WIND[nn];
	}
	for (nn = 0; nn < Ns; nn++) m_BUFF_WIND[nn] /= max;

	// выдача сигнала о готовности оконной функции:
	m_wind_ready = true;

	return 0;
}

double wind_fcn::cheby_poly(int n, double x)
{

	double res;
	if (fabs(x) <= 1) res = cos(n*acos(x));
	else              res = cosh(n*acosh(x));
	return res;
}
//------------------------------------------------------------------------------
// Окно с плоским верхом:
int wind_fcn::FlatTop()
{
	// выделяем память для хранения коэффициентов оконной функции:
	allocate();

	double Ns = (double)m_order;

	for (int n = 0 ; n < Ns; n++)
	{
		m_BUFF_WIND[n] = 0.21557895 - 0.41663158 * cos(PI2 * n / (Ns - 1) ) + 0.277263158 * cos(4 * PI0 * n / (Ns - 1) ) - 0.083578947 * cos(6 * PI0 * n / (Ns - 1) ) + 0.006947368 * cos(8 * PI0 * n / (Ns - 1) );
	}

	// выдача сигнала о готовности оконной функции:
	m_wind_ready = true;

	return 0;
}
//------------------------------------------------------------------------------
// Окно Гаусса:
int wind_fcn::Gaussian(double alpha)
{
	// выделяем память для хранения коэффициентов оконной функции:
	allocate();

	int    Ns = m_order;
	int    n     = 0;
	double sigma = 0;

	for (int k = 0 ; k < Ns; k++)
	{
		n = k - Ns/2;
		if (n >= 0)  n = k - Ns/2 + 1;

		sigma = ((double)Ns-1) / 2 / alpha;
		m_BUFF_WIND[k] = exp(-(double)n * (double)n / 2 / sigma / sigma);
	}

	// выдача сигнала о готовности оконной функции:
	m_wind_ready = true;

	return 0;
}
//------------------------------------------------------------------------------
// окно Хемминга:
int wind_fcn::Hamming()
{
	// выделяем память для хранения коэффициентов оконной функции:
	allocate();

	int Ns = m_order;

	for (int n = 0 ; n < Ns ; n++) 
	{
		m_BUFF_WIND[n] = 0.54 - 0.46 * cos(PI2 * n / (Ns-1));
	}

	// выдача сигнала о готовности оконной функции:
	m_wind_ready = true;

	return 0;
}
//------------------------------------------------------------------------------
// окно Ханна:
int wind_fcn::Hann()
{
	// выделяем память для хранения коэффициентов оконной функции:
	allocate();

	int Ns = m_order;

	for (int n = 0; n < Ns; n++)
	{
		m_BUFF_WIND[n] = 0.5 - 0.5 * cos( PI2 * n / (Ns-1) );
	}

	// выдача сигнала о готовности оконной функции:
	m_wind_ready = true;

	return 0;
}
//------------------------------------------------------------------------------
// Окно Кайзера:
int wind_fcn::Kaiser(double betta)
{
	// выделяем память для хранения коэффициентов оконной функции:
	allocate();

	int Ns = m_order;

	double A = 0;
	double B = 0;
	double C = 0;

	for (int n = 0; n < Ns; n++)
	{
		A = ((double)n - ( (double)Ns - 1 ) / 2) / ( ((double)Ns - 1 ) / 2);
		B = betta * sqrt(1 - A * A);
		C = betta;

		m_BUFF_WIND[n] = m_SPEC_FCN.mod_bessel_In(B, 0) / m_SPEC_FCN.mod_bessel_In(C, 0);

	}

	// выдача сигнала о готовности оконной функции:
	m_wind_ready = true;

	return 0;
}
//------------------------------------------------------------------------------
// окно Наталла:
int wind_fcn::Nutall()
{
	// выделяем память для хранения коэффициентов оконной функции:
	allocate();

	int Ns = m_order;
	
	for (int n = 0; n < Ns; n++) 
	{
		m_BUFF_WIND[n] = 0.3635819 - 0.4891775 * cos(2 * PI0 * n / (Ns - 1) ) + 0.1365995 * cos(4 * PI0 * n / (Ns - 1)) - 0.0106411 * cos(6 * PI0 * n / (Ns - 1));
	}

	// выдача сигнала о готовности оконной функции:
	m_wind_ready = true;

	return 0;
}
//------------------------------------------------------------------------------
// окно Парзена
int wind_fcn::Parzen()
{
	// выделяем память для хранения коэффициентов оконной функции:
	allocate();

	int    Ns = m_order;
	int    n = 0;

	for (int k = 0; k < Ns; k++)
	{
		n = k - Ns / 2;
		if (n >= 0)  n = k - Ns / 2 + 1;

		if (fabs(n)>=0 && fabs(n) <= (Ns-1)/4 )
		{
			m_BUFF_WIND[k] = 1 - 6 * fabs((double)n)*fabs((double)n) / ((double)Ns*(double)Ns / 4) + 6 * fabs((double)n)*fabs((double)n)*fabs((double)n) / ((double)Ns*(double)Ns*(double)Ns / 8);
		}
		else if(fabs(n) < Ns/2 && fabs(n) > (Ns - 1) / 4 )
		{
			m_BUFF_WIND[k] = 2 * pow( 1 - fabs((double)n)/((double)Ns/2) , 3);
		}
	}

	// выдача сигнала о готовности оконной функции:
	m_wind_ready = true;

	return 0;
}
//------------------------------------------------------------------------------
// Прямоугольное окно
int wind_fcn::Rectangular()
{
	// выделяем память для хранения коэффициентов оконной функции:
	allocate();

	for (int n = 0; n < m_order; n++) 
	{
		m_BUFF_WIND[n] = 1;
	}

	// выдача сигнала о готовности оконной функции:
	m_wind_ready = true;

	return 0;
}
//------------------------------------------------------------------------------
// Треугольное окно
int wind_fcn::Triangular()
{
	// выделяем память для хранения коэффициентов оконной функции:
	allocate();

	int Ns = m_order;

	if ( Ns % 2 == 0) 
	{
		for (int n = 0; n < Ns; n++)
		{
			m_BUFF_WIND[n] = (1.0 - fabs(((double)n - ((double)Ns - 1) / 2) / ((((double)Ns - 1) + 1) / 2)));
		}
	}
	else 
	{
		for (int n = 0; n < Ns; n++)
		{
			m_BUFF_WIND[n] = (1.0 - fabs(((double)n - ((double)Ns - 1) / 2) / ((((double)Ns - 1) + 2) / 2)));
		}
	}

	// выдача сигнала о готовности оконной функции:
	m_wind_ready = true;

	return 0;
}
//------------------------------------------------------------------------------
// окно Тьюки
int wind_fcn::Tukey(double R)
{
	// выделяем память для хранения коэффициентов оконной функции:
	allocate();

	int    Ns = m_order;
	double x  = 0;

	for (int n = 0 ; n < Ns ; n++) 
	{

		x = (double)n / ((double)Ns - 1);

		if ( x >=0 && x < R / 2 ) 
		{
			m_BUFF_WIND[n] = 0.5 + 0.5 * cos( PI2 / R * ( x - 0.5*R ) );
		}
		else if ( x >= 1 - 0.5 * R && x <= 1 )
		{
			m_BUFF_WIND[n] = 0.5 + 0.5 * cos(PI2 / R * (x - 1 + 0.5*R) );
		}
		else 
		{
			m_BUFF_WIND[n] = 1;
		}
	}

	// выдача сигнала о готовности оконной функции:
	m_wind_ready = true;

	return 0;
}


